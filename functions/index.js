/**
 * Import function triggers from their respective submodules:
 *
 * const {onCall} = require("firebase-functions/v2/https");
 * const {onDocumentWritten} = require("firebase-functions/v2/firestore");
 *
 * See a full list of supported triggers at https://firebase.google.com/docs/functions
 */

const { onRequest } = require("firebase-functions/v2/https");
const logger = require("firebase-functions/logger");
const { YoutubeTranscript } = require("youtube-transcript");
const admin = require("firebase-admin");
const OpenAI = require("openai");

admin.initializeApp();

const db = admin.firestore();
const openai = new OpenAI({
  apiKey:
    "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",
});
// Create and deploy your first functions
// https://firebase.google.com/docs/functions/get-started

exports.helloWorld = onRequest((request, response) => {
  logger.info("Hello logs!", { structuredData: true });
  response.send("Hello from Firebase!");
});

/**
 * Cloud Function to fetch YouTube transcript.
 *
 * @param {Object} req - The request object.
 * @param {Object} res - The response object.
 */
exports.getYoutubeTranscript = onRequest(async (req, res) => {
  const videoId = req.query.videoId || req.body.videoId;
  if (!videoId) {
    res.status(400).json({ error: "Missing videoId parameter" });
    return;
  }

  try {
    const transcript = await YoutubeTranscript.fetchTranscript(videoId);
    // Optionally, just return the text lines:
    // const lines = transcript.map((line) => line.text);
    const lines = transcript.reduce(
      (result, line) => result + " " + line.text,
      ""
    );
    res.status(200).json({ lines });
  } catch (err) {
    logger.error("Error fetching transcript:", err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * Cloud Function to generate quiz from YouTube video.
 *
 * @param {Object} req - The request object.
 * @param {Object} res - The response object.
 */
exports.generateQuizFromYoutube = onRequest(async (req, res) => {
  const videoId = req.query.videoId || req.body.videoId;
  const videoTitle =
    req.query.videoTitle || req.body.videoTitle || "Untitled Video";
  let transcriptText = req.query.transcript || req.body.transcript;

  if (!videoId || !transcriptText) {
    res.status(400).json({ error: "Missing videoId parameter" });
    return;
  }

  // Check if AI-generated questions already exist
  const quizDocRef = db.collection("quizzes").doc(videoId);
  const quizDoc = await quizDocRef.get();
  if (quizDoc.exists && quizDoc.data().aiGeneratedQuestions) {
    res.status(200).json({
      message: "Questions are already generated by AI for this video.",
      alreadyGenerated: true,
    });
    return;
  }
  const sanitize = (text) => text.replace(/`/g, "'");

  try {
    // 1. Fetch transcript
    transcriptText = transcriptText.slice(0, 20000);

    // 2. Prepare prompt
    const prompt = `Based on the following YouTube video transcript, generate 20 multiple-choice questions (MCQs) that test the viewer's understanding of the video titled: "${sanitize(
      videoTitle
    )}"
Requirements:
All questions and options could be written in English, even if the original content is in another language.
Each question must be under 200 characters.
Each option must be under 50 characters.
Ensure all questions are relevant to the Transcript and the topic of the video.
Avoid repeating the same question or options.
Vary the difficulty and concepts as much as possible.
Output the result strictly in the JSON format shown below.

JSON Output Format:
[
  {
    "que": "Your question text here",
    "options": [
      "Option 1",
      "Option 2",
      "Option 3",
      "Option 4"
      ],
    "correctAnswer": 0, // Index of the correct answer (0-3)
  }
]
Transcript: ${sanitize(transcriptText)}
`;

    console.log("prompt:", prompt);
    // 3. Call OpenAI
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      store: true,
      messages: [{ role: "user", content: prompt }],
    });
    logger.info(`OpenAI response received; ${completion}`);
    console.log("completion:", completion);

    let content = completion.choices?.[0]?.message?.content || "";

    if (!content) {
      logger.error("No content returned from OpenAI.");
      throw new Error("No content returned from OpenAI.");
    }

    content = content.replace(/```json|```/g, "").trim();

    let result;
    try {
      result = JSON.parse(content);
    } catch (e) {
      logger.error("Failed to parse JSON:", e.message);
      res.status(500).json({ error: "Failed to parse AI response as JSON." });
      return;
    }
    console.log("Parsed result:", result);

    if (!validateMCQFormat(result)) {
      logger.error("Result is NOT in valid MCQ format.");
      res
        .status(500)
        .json({ error: "AI response is not in valid MCQ format." });
      return;
    }

    // 4. Inflate questions
    const inflatedQuestions = inflateQuestions(result);

    // 5. Write to Firestore
    // Ensure quiz document exists or is merged

    await db.collection("quizzes").doc(videoId).set(
      {
        videoTitle: videoTitle,
        aiGeneratedQuestions: true,
      },
      { merge: true }
    );

    // Add questions to subcollection
    const questionsCollectionRef = db
      .collection("quizzes")
      .doc(videoId)
      .collection("questions");
    const addQuestionPromises = inflatedQuestions.map((que) =>
      questionsCollectionRef.add({ ...que, createdAt: new Date() })
    );
    const addedDocs = await Promise.all(addQuestionPromises);

    res.status(200).json({
      message: "Quiz generated and saved successfully.",
      questionIds: addedDocs.map((doc) => doc.id),
    });
  } catch (err) {
    logger.error("Error:", err.message);
    res.status(500).json({ error: err.message });
  }
});

/**
 * Validate the format of MCQ data.
 *
 * @param {Array} data - The MCQ data to validate.
 * @returns {boolean} - True if valid, false otherwise.
 */
function validateMCQFormat(data) {
  if (!Array.isArray(data)) return false;
  for (const item of data) {
    if (
      typeof item !== "object" ||
      typeof item.correctAnswer !== "number" ||
      typeof item.que !== "string" ||
      !Array.isArray(item.options) ||
      item.options.length !== 4 ||
      !item.options.every((opt) => typeof opt === "string")
    ) {
      return false;
    }
  }
  return true;
}

/**
 * Inflate questions to add additional metadata.
 *
 * @param {Array} data - The original MCQ data.
 * @returns {Array} - The inflated MCQ data with metadata.
 */
function inflateQuestions(data) {
  return data.map((item) => ({
    addedBy: "AI",
    correctAnswer: item.correctAnswer,
    que: item.que,
    options: item.options.map((option) => ({
      clicks: 0,
      option: option,
    })),
    likedBy: [],
    reports: 0,
    totalAttempts: 0,
    type: "multiple-options",
  }));
}
